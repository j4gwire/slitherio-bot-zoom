// ==UserScript==
// @name         Slither.io JavaScript Bot & Zoom
// @namespace    http://slither.io/
// @version      1.2.1
// @description  Combines JavaScript bot and manual zooming functionality for Slither.io.
// @author       j4gwire
// @grant        none
// @match        http://slither.com/io
// @match        http://slither.io/?c
// @match        http://slither.io
// @match        *://Slither.com/io/*
// @license      MIT
// @downloadURL  https://github.com/j4gwire/slitherio-bot-zoom
// @updateURL    https://github.com/j4gwire/slitherio-bot-zoom
// ==/UserScript==

// ====================================================================
// SLITHER.IO BOT CODE
// ====================================================================

var el = document.getElementsByTagName('iframe');
for (var i = 0; i < el.length; i++) {
    var currentEl = el[i];
    currentEl.remove();
}

// remove the vote text
if (document.getElementById("votetxth") !== null) {
    document.getElementById("votetxth").remove()
}
if (document.getElementById("trumpbtnh") !== null) {
    document.getElementById("trumpbtnh").remove()
}
if (document.getElementById("kamalabtnh") !== null) {
    document.getElementById("kamalabtnh").remove()
}


if (window.top != window.self)

REALSCORE = 10;
REALDNA = [1,1,1,1,1,1,1,1,1,1,1,1];

BESTRANK = 1000;
BESTSCORE = 1;

printbot = function() {
    console.log("Dumping bot data:\nREALDNA = " + JSON.stringify(REALDNA) + ";\nREALSCORE = " + REALSCORE + ";\nBESTRANK = " + BESTRANK + ";\nBESTSCORE = " + BESTSCORE + ";");
}

savedna = function() {
    if(typeof(Storage) !== "undefined") {
        localStorage["REALSCORE"] = REALSCORE;
        localStorage["REALDNA"] = JSON.stringify(REALDNA);
        localStorage["BESTRANK"] = BESTRANK;
        localStorage["BESTSCORE"] = BESTSCORE;
    }
}

cleardna = function() {
    localStorage.removeItem("REALSCORE");
    localStorage.removeItem("REALDNA");

    localStorage.removeItem("BESTRANK");
    localStorage.removeItem("BESTSCORE");

    REALSCORE = 30;
    BESTRANK = 1000;

    var distavoid = 90;
    var preykerroin = 5;
    var viholliskerroin = 544;
    var vaarakerroin = 200;
    var chargedistance = 500;
    var pakoondistance = 70;
    var keskikerroin = 2.0;
    var keskihakukerroin = 0.1;

    REALDNA = [distavoid,preykerroin,viholliskerroin,vaarakerroin,chargedistance,pakoondistance,keskikerroin,keskihakukerroin];

    TESTDNA = REALDNA.slice();
    TESTSCORE = REALSCORE;

    testingdna = 1;
    DNA = REALDNA.slice();

    savedna();
}

if(typeof(Storage) !== "undefined") {
    // Code for localStorage/sessionStorage.
    if (!localStorage.REALSCORE || !localStorage.REALDNA || !localStorage.BESTRANK || !localStorage.BESTSCORE) {
        cleardna();
    }
    else
    {
        REALSCORE = localStorage["REALSCORE"]*1;
        REALDNA = JSON.parse(localStorage["REALDNA"]);
        BESTRANK = localStorage["BESTRANK"]*1;
        BESTSCORE = localStorage["BESTSCORE"]*1;
    }
} else {
    // Sorry! No Web Storage support..
}


TESTDNA = REALDNA.slice();
TESTSCORE = REALSCORE;

testingdna = 1;
DNA = REALDNA.slice();

var injected_dead = true;

var lastscore = 0;
var bestscore = 0;

var lastrank = 0;
var bestrank = 1000;
var uhka = false;


var ruokakerroin = 1/40;
var ruokapower = 1;
var vihollispower = 2;
var vaarapower = 2;
var preypower = 1;
var keskipower = 1;


var preychase = true;

var learnrate = 0.3;
var	precision = 100;
var EnableBot = true; // Bot is enabled by default

INJECTED = function() {
    var kerroin = 10000;
    // The Bot's 'E' key handler uses addEventListener, which will not conflict with the Zoom's onkeydown override.
    document.addEventListener('keydown', (event) => {
        var ShouldHandleKeyDown = true;
        if (event.key === 'e' && ShouldHandleKeyDown === true) {
            console.log("Toggling bot");
            EnableBot = !EnableBot;
            // Update UI status when toggled by key
            if (document.getElementById("bot-status")) {
                document.getElementById("bot-status").textContent = EnableBot ? "Enabled" : "Disabled";
                document.getElementById("bot-status").style.color = EnableBot ? "lime" : "red";
            }
        }
    });

    if (animating && EnableBot) {
        if (slither) {
            accelerate = false;
            injected_dead = false;

            //xm = grd-slither.xx;
            //ym = grd-slither.yy;

            xt = 0;
            yt = 0;

            mindist = grd;


            for (var i = 0; i < preys.length; i++) {
                xtd = (preys[i].xx-slither.xx);
                ytd = (preys[i].yy-slither.yy);

                dist = Math.sqrt(xtd*xtd + ytd*ytd);

                xt += xtd/Math.pow(dist,preypower+1)*DNA[1];
                yt += ytd/Math.pow(dist,preypower+1)*DNA[1];

                if (dist < DNA[4] && preychase)
                {
                    accelerate = true;
                }
            }

            uhka = false;
            for (var i = 0; i < slithers.length; i++) {
                //alert(myStringArray[i]);

                target = slithers[i];

                if (slither.id!=target.id)
                {
                    xtd = (target.xx-slither.xx);
                    ytd = (target.yy-slither.yy);

                    dist = Math.sqrt(xtd*xtd + ytd*ytd)-DNA[0];
                    dist = Math.max(1, dist);

                    xt += -xtd/Math.pow(dist,vihollispower+1)*DNA[2];
                    yt += -ytd/Math.pow(dist,vihollispower+1)*DNA[2];



                    if (dist < DNA[5])
                    {
                        accelerate = true;
                    }

                    if (dist<mindist)
                    {
                        uhka = target;
                        mindist = dist;
                        /*if (mindist<300)
                        {
                            accelerate = true;
                        }*/
                    }

                    parts = target.pts;
                    for (var k = 0; k < parts.length; k++)
                    {
                        part = parts[k];

                        xtd = (part.xx-slither.xx);
                        ytd = (part.yy-slither.yy);

                        dist = Math.sqrt(xtd*xtd + ytd*ytd)-DNA[0];
                        dist = Math.max(1, dist);

                        xt += -xtd/Math.pow(dist,vaarapower+1)*DNA[3];
                        yt += -ytd/Math.pow(dist,vaarapower+1)*DNA[3];
                    }

                }
            }


            if (!(preychase && preys.length>0))
            {
                for (var i = 0; i < foods_c; i++) {
                    //alert(myStringArray[i]);

                    xtd = (foods[i].xx-slither.xx);
                    ytd = (foods[i].yy-slither.yy);

                    dist = Math.sqrt(xtd*xtd + ytd*ytd);

                    //xt += Math.pow(ruokakerroin*foods[i].fw,2)*xtd/Math.pow(dist,ruokapower+1);
                    //yt += Math.pow(ruokakerroin*foods[i].fw,2)*ytd/Math.pow(dist,ruokapower+1);
                    xt += Math.pow(foods[i].gr,2)*xtd/Math.pow(dist,ruokapower+1);
                    yt += Math.pow(foods[i].gr,2)*ytd/Math.pow(dist,ruokapower+1);
                }

                xtd = (grd-slither.xx);
                ytd = (grd-slither.yy);

                dist = Math.sqrt(xtd*xtd + ytd*ytd);

                xt += xtd/Math.pow(grd-dist,keskipower+1)*DNA[6];
                yt += ytd/Math.pow(grd-dist,keskipower+1)*DNA[6];

                xt += xtd/grd*DNA[7];
                yt += ytd/grd*DNA[7];


            }

            xm = xt*kerroin;
            ym = yt*kerroin;

            lsxm = -xm;
            lsym = -ym;

            if (accelerate)
            {
                setAcceleration(1);
            }
            else
            {
                setAcceleration(0);
            }

            //console.log("xx:" +  view_xx + "yy:" + view_yy);
            //console.log("slither.xx:" +  slither.xx + "slither.yy:" + slither.yy);
            //console.log("slither.fx:" +  slither.fx + "slither.fy:" + slither.fy);
            //console.log("fvx:" +  fvx + "fvy:" + fvy);
            //console.log("");

            //console.log("foods_c:" + foods_c);
            //console.log("slithers.length:" + slithers.length);

            //console.log("D:" + Math.sqrt(xm*xm + ym*ym));

            lastscore = Math.floor(150 * (fpsls[slither.sct] + slither.fam / fmlts[slither.sct] - 1) - 50) / 10;
            if (!lastscore)
            {
                lastscore = 1;
            }
            lastrank = rank;
            if (!lastrank)
            {
                lastrank = 500;
            }
        }
        else
        {
            if (!injected_dead)
            {
                injected_dead = true;

                if (lastscore>bestscore)
                {
                    console.log("Last score: " + lastscore + "(new best)");
                    bestscore = lastscore;

                    BESTSCORE = bestscore;
                }
                else
                {
                    console.log("Last score: " + lastscore + " Best: " + bestscore);
                }

                if (lastrank<bestrank)
                {
                    console.log("Last rank: " + lastrank + "(new best)");
                    bestrank = lastrank;

                    BESTRANK = bestrank;
                }
                else
                {
                    console.log("Last rank: " + lastrank + " Best: " + bestrank);
                }

                if (testingdna>0)
                {
                    TESTSCORE = lastscore/(lastrank+1);

                }
                else
                {
                    REALSCORE = (REALSCORE+lastscore/lastrank)/2;
                }
                lastscore = 0;

                for (var key in DNA)
                {
                    if (TESTSCORE > REALSCORE)
                    {
                        var mul = TESTSCORE/REALSCORE
                        REALDNA[key] = (REALDNA[key] + TESTDNA[key]*mul)/(1+mul);
                        REALDNA[key] = Math.round(REALDNA[key]*precision)/precision;
                    }

                    if (testingdna<0)
                    {
                        TESTDNA[key] = REALDNA[key] + REALDNA[key]*(Math.random() - Math.random())*learnrate;
                        TESTDNA[key] = Math.round(TESTDNA[key]*precision)/precision;
                    }
                }

                savedna();

                testingdna = -testingdna;

                if (testingdna>0)
                {
                    DNA = TESTDNA.slice();
                }
                else
                {
                    DNA = REALDNA.slice();
                }
                //console.log("DNA = [" + DNA + "];");

                setTimeout(connect, 3000);
                //console.log("Reconnecting");
            }
        }
    }
}

var injectbot = function() {
    if (typeof(redraw) != "undefined")
    {
        oldredraw = redraw;

        redraw = function() {
            INJECTED();
            oldredraw();
        }
        console.log("Bot injected");
        window.onmousemove = null;
    }
    else
    {
        setTimeout(injectbot, 1000);
        console.log("Bot retrying injection");
    }
}
injectbot();

// === BOT UI MENU ===
(function() {
    'use strict';

    function createBotUI() {
        const ui = document.createElement("div");
        ui.id = "slither-bot-ui";
        ui.style.cssText = `
            background: rgba(0,0,0,0.75);
            color: #fff;
            font-family: Arial, sans-serif;
            font-size: 14px;
            padding: 10px;
            border: 2px solid #3a3a3a;
            border-radius: 8px;
            position: fixed;
            top: 50px;
            left: 50px;
            z-index: 99999;
            min-width: 200px;
            user-select: none;
        `;

        ui.innerHTML = `
            <div style="font-weight: bold; font-size: 16px; margin-bottom: 10px; text-align: center;">
                Slither JavaScript Bot & Zoom
            </div>
            <div style="margin-bottom: 6px;">
                Bot: <span id="bot-status" style="color: ${EnableBot ? "lime" : "red"};">${EnableBot ? "Enabled" : "Disabled"}</span>
            </div>
            <button id="toggle-bot" style="
                margin-top: 6px;
                width: 100%;
                padding: 6px;
                background: #444;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
            ">Toggle Bot (E)</button>
            <div style="margin-top: 10px; font-size: 13px; line-height: 1.3;">
                <strong>Zoom Controls:</strong><br>
                1 = Reset Zoom<br>
                8 = Zoom Out<br>
                9 = Zoom In
            </div>
            <div style="margin-top: 10px; font-size: 12px; color: #ccc; text-align: center;">
                By: j4gwire
            </div>
        `;

        document.body.appendChild(ui);

        // Toggle button syncs with EnableBot
        const statusSpan = document.getElementById("bot-status");
        document.getElementById("toggle-bot").addEventListener("click", () => {
            EnableBot = !EnableBot;
            statusSpan.textContent = EnableBot ? "Enabled" : "Disabled";
            statusSpan.style.color = EnableBot ? "lime" : "red";
        });
    }

    // Wait until body exists
    const uiInterval = setInterval(() => {
        if (document.body) {
            clearInterval(uiInterval);
            createBotUI();
        }
    }, 500);
})();


// ====================================================================
// SLITHER.IO ZOOMING CODE
// ====================================================================

// Enable debug logging
window.logDebugging = false;
window.log = function() {
    if (window.logDebugging) {
        console.log.apply(console, arguments);
    }
};

window.zoomMultiplier = 1.0;

window.updateZoom = function() {
    window.gsc = window.zoomMultiplier;
    // NOTE: This assumes 'window.initZoomOverlay()' was run to create 'zoom_overlay'.
    // Since the original script relies on a game function for this, we add a check.
    const zoomOverlay = document.getElementById("zoom_overlay");
    if (zoomOverlay) {
        zoomOverlay.innerHTML =
            `Press (8/9) to change zoom: ${window.zoomMultiplier.toFixed(1)}`;
    }
};


window.recursiveZoomUpdate = function() {
    window.gsc = window.zoomMultiplier;
    requestAnimationFrame(window.recursiveZoomUpdate);
};


window.resetZoom = function() {
    window.zoomMultiplier = 1.0;
    window.updateZoom();
};

window.adjustZoom = function(amount) {
    window.zoomMultiplier = Math.max(0.2, Math.min(3.0, window.zoomMultiplier + amount));
    window.updateZoom();
};

// **Key Bindings Implementation**
// This will correctly save and call the Bot's old keydown handler if one existed
// before the Zoom script was injected.
document.oldKeyDown = document.onkeydown;
document.onkeydown = function(e) {
    // Call any existing keydown handler first (which could be the original game's or another script's)
    if (typeof document.oldKeyDown === "function") {
        document.oldKeyDown(e);
    }

    if (document.activeElement.parentElement !== window.nick_holder) {
        if (e.keyCode === 57) { // Key 9: Zoom Out
            window.adjustZoom(0.1);
        } else if (e.keyCode === 56) { // Key 8: Zoom In
            window.adjustZoom(-0.1);
        } else if (e.keyCode === 49) { // Key 1: Reset Zoom
            window.resetZoom();
        }
    }
};

window.initt = function() {
    // NOTE: window.initZoomOverlay() is a function that must be defined by the Slither.io game
    // or another script to create the necessary 'zoom_overlay' element.
    if (typeof window.initZoomOverlay === 'function') {
        window.initZoomOverlay();
    }
    window.updateZoom();
    window.recursiveZoomUpdate();
};

window.initt();
